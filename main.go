package main

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/jackc/pgx/v4/pgxpool"
)

const (
	dbURL        = "postgres://temp16:temp16@localhost:5432/cve"
	zipURL       = "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"
	zipFileName  = "cvelistV5-main.zip"
	cveDataPath  = "cvelistV5-main/cves/"
	sampleSuffix = ".json"
)

func main() {
	ctx := context.Background()

	fmt.Println("Connecting to PostgreSQL...")
	// Use connection pool for better management of connections
	pool, err := pgxpool.Connect(ctx, dbURL)
	if err != nil {
		log.Fatalf("Unable to connect to database: %v\n", err)
	}
	defer pool.Close()
	fmt.Println("Connected to PostgreSQL.")

	fmt.Println("Ensuring the CVEs table exists...")
	if err := ensureTableExists(ctx, pool); err != nil {
		log.Fatalf("Failed to ensure table exists: %v\n", err)
	}
	fmt.Println("Ensured the CVEs table exists.")

	fmt.Println("Downloading and processing CVE files...")
	if err := processCVEFiles(ctx, pool); err != nil {
		log.Fatalf("Failed to process CVE files: %v\n", err)
	}
	fmt.Println("Completed processing CVE files.")
}

// Ensure the table exists
func ensureTableExists(ctx context.Context, pool *pgxpool.Pool) error {
	var exists bool
	checkTableQuery := `
    SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE  table_schema = 'cve'
        AND    table_name   = 'cves'
    );
    `

	err := pool.QueryRow(ctx, checkTableQuery).Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check if table exists: %v", err)
	}

	if !exists {
		createTableQuery := `
        CREATE TABLE cve.cves (
            assigner_org_id TEXT,
            assigner_short_name TEXT,
            cve_id TEXT NOT NULL,
            date_published TIMESTAMPTZ,
            date_reserved TIMESTAMPTZ,
            date_updated TIMESTAMPTZ,
            state TEXT,
            CONSTRAINT unique_cve_id UNIQUE (cve_id)
        );
        `

		_, err := pool.Exec(ctx, createTableQuery)
		if err != nil {
			return fmt.Errorf("failed to create table: %v", err)
		}
		fmt.Println("Table cves created successfully.")
	} else {
		fmt.Println("Table cves already exists.")
	}

	return nil
}

// Download and process CVE files
func processCVEFiles(ctx context.Context, pool *pgxpool.Pool) error {
	client := resty.New()
	resp, err := client.R().Get(zipURL)
	if err != nil {
		return fmt.Errorf("failed to download zip file: %v", err)
	}

	zipReader, err := zip.NewReader(bytes.NewReader(resp.Body()), int64(len(resp.Body())))
	if err != nil {
		return fmt.Errorf("failed to read zip file: %v", err)
	}

	for _, file := range zipReader.File {
		if strings.HasSuffix(file.Name, sampleSuffix) {
			rc, err := file.Open()
			if err != nil {
				return fmt.Errorf("failed to open file in zip: %v", err)
			}
			defer rc.Close()

			data, err := ioutil.ReadAll(rc)
			if err != nil {
				return fmt.Errorf("failed to read file: %v", err)
			}

			// Skip delta.json and deltaLog.json
			if file.Name == "cvelistV5-main/cves/delta.json" || file.Name == "cvelistV5-main/cves/deltaLog.json" {
				continue
			}

			err = processCVEData(ctx, pool, data)
			if err != nil {
				log.Printf("Failed to process CVE data from file %s: %v\n", file.Name, err)
			}
		}
	}

	return nil
}

func processCVEData(ctx context.Context, pool *pgxpool.Pool, data []byte) error {
	var cve map[string]interface{}
	err := json.Unmarshal(data, &cve)
	if err != nil {
		return fmt.Errorf("failed to unmarshal json: %v", err)
	}

	cveMetadata, ok := cve["cveMetadata"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("failed to get cveMetadata from JSON data")
	}

	cveID, ok := cveMetadata["cveId"].(string)
	if !ok {
		return fmt.Errorf("failed to get cveId from JSON data")
	}

	assignerOrgID, _ := cveMetadata["assignerOrgId"].(string)
	assignerShortName, _ := cveMetadata["assignerShortName"].(string)
	datePublishedStr, _ := cveMetadata["datePublished"].(string)
	dateReservedStr, _ := cveMetadata["dateReserved"].(string)
	dateUpdatedStr, _ := cveMetadata["dateUpdated"].(string)
	state, _ := cveMetadata["state"].(string)

	datePublished, _ := time.Parse(time.RFC3339, datePublishedStr)
	dateReserved, _ := time.Parse(time.RFC3339, dateReservedStr)
	dateUpdated, _ := time.Parse(time.RFC3339, dateUpdatedStr)

	query := `
        INSERT INTO cve.cves (assigner_org_id, assigner_short_name, cve_id, date_published, date_reserved, date_updated, state)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        ON CONFLICT (cve_id) DO UPDATE
        SET assigner_org_id = EXCLUDED.assigner_org_id,
            assigner_short_name = EXCLUDED.assigner_short_name,
            date_published = EXCLUDED.date_published,
            date_reserved = EXCLUDED.date_reserved,
            date_updated = EXCLUDED.date_updated,
            state = EXCLUDED.state;
    `

	_, err = pool.Exec(ctx, query, assignerOrgID, assignerShortName, cveID, datePublished, dateReserved, dateUpdated, state)
	if err != nil {
		return fmt.Errorf("failed to upsert CVE: %v", err)
	}

	fmt.Printf("CVE %s upserted successfully.\n", cveID)
	return nil
}
