package main

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4/pgxpool"
)

const (
	dbURL  = "$DB_URL"
	zipURL = "$ZIP_URL"
)

// CVEData represents the structure of CVE data with specific field order
type CVEData struct {
	AssignerOrgID     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CVEID             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

// Global variable to store the path of the file containing processed CVE IDs
const processedCVEFile = "processed_cve_ids.txt"

func main() {

	dbURL := os.Getenv("DB_URL")
	zipURL := os.Getenv("ZIP_URL")

	if dbURL == "" || zipURL == "" {
		fmt.Println("Environment variables DB_URL or ZIP_URL are not set")
		return
	}

	ctx := context.Background()

	fmt.Println("Connecting to PostgreSQL...")
	// Connect to PostgreSQL
	conn, err := pgxpool.Connect(ctx, dbURL)
	if err != nil {
		log.Fatalf("Unable to connect to database: %v\n", err)
	}
	defer conn.Close()

	fmt.Println("Connected to PostgreSQL.")

	fmt.Println("Ensuring the CVEs table exists...")
	// Ensure the CVEs table exists
	if err := ensureTableExists(ctx, conn); err != nil {
		log.Fatalf("Failed to ensure table exists: %v\n", err)
	}
	fmt.Println("Ensured the CVEs table exists.")

	fmt.Println("Creating index on cve_data column...")
	// Create index on cve_data column
	if err := createIndexOnCVEData(ctx, conn); err != nil {
		log.Fatalf("Failed to create index on cve_data column: %v\n", err)
	}
	fmt.Println("Index on cve_data column created successfully.")

	fmt.Println("Downloading and extracting CVE data...")
	// Download and extract CVE data
	if err := downloadAndExtractCVEData(zipURL, "cve_data"); err != nil {
		log.Fatalf("Failed to download and extract CVE data: %v\n", err)
	}
	fmt.Println("Completed downloading and extracting CVE data.")

	fmt.Println("Processing CVE data files...")
	// Process extracted CVE data files
	if err := processCVEDataFiles(ctx, conn, "cve_data"); err != nil {
		log.Fatalf("Failed to process CVE data files: %v\n", err)
	}
	fmt.Println("Completed processing CVE data files.")
}

// Ensure the table exists
func ensureTableExists(ctx context.Context, conn *pgxpool.Pool) error {
	const createTableQuery = `
	CREATE TABLE IF NOT EXISTS cve.cves (
		cve_id TEXT PRIMARY KEY,
		cve_data JSONB,
		version NUMERIC DEFAULT 1.0
	);

    `

	_, err := conn.Exec(ctx, createTableQuery)
	return err
}

// Create index on cve_data column
func createIndexOnCVEData(ctx context.Context, conn *pgxpool.Pool) error {
	const createIndexQuery = `
    CREATE INDEX IF NOT EXISTS idx_cve_data ON cve.cves USING GIN (cve_data);
    `

	_, err := conn.Exec(ctx, createIndexQuery)
	return err
}

// Download and extract CVE data from a ZIP file URL
func downloadAndExtractCVEData(url, destDir string) error {
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download ZIP file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download ZIP file: status code %d", resp.StatusCode)
	}

	zipData, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read ZIP file data: %v", err)
	}

	zipReader, err := zip.NewReader(bytes.NewReader(zipData), int64(len(zipData)))
	if err != nil {
		return fmt.Errorf("failed to create ZIP reader: %v", err)
	}

	for _, file := range zipReader.File {
		filePath := filepath.Join(destDir, file.Name)

		if file.FileInfo().IsDir() {
			if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
				return fmt.Errorf("failed to create directory: %v", err)
			}
			continue
		}

		if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
			return fmt.Errorf("failed to create directory: %v", err)
		}

		outFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			return fmt.Errorf("failed to open file for writing: %v", err)
		}

		rc, err := file.Open()
		if err != nil {
			return fmt.Errorf("failed to open file in ZIP archive: %v", err)
		}

		_, err = io.Copy(outFile, rc)
		if err != nil {
			return fmt.Errorf("failed to copy file data: %v", err)
		}

		outFile.Close()
		rc.Close()
	}

	return nil
}

// Process all CVE data files in the specified directory
func processCVEDataFiles(ctx context.Context, conn *pgxpool.Pool, dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".json") {
			// Skip processing if file path contains "delta.json" or "deltaLog.json"
			if strings.Contains(path, "delta.json") || strings.Contains(path, "deltaLog.json") {
				fmt.Printf("Skipping file %s\n", path)
				return nil
			}

			jsonData, err := ioutil.ReadFile(path)
			if err != nil {
				return fmt.Errorf("failed to read JSON file %s: %v", path, err)
			}
			// Process CVE data
			if err := processCVEData(ctx, conn, jsonData); err != nil {
				return fmt.Errorf("failed to process CVE data from file %s: %v", path, err)
			}
		}
		return nil
	})
}

func processCVEData(ctx context.Context, conn *pgxpool.Pool, jsonData []byte) error {
	// Parse JSON data
	var data map[string]interface{}
	if err := json.Unmarshal(jsonData, &data); err != nil {
		return fmt.Errorf("failed to parse JSON data: %v", err)
	}

	// Extract CVE metadata
	cveMetadata, ok := data["cveMetadata"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("failed to get cveMetadata from JSON data")
	}

	// Extract fields from cveMetadata
	cveID, ok := cveMetadata["cveId"].(string)
	if !ok {
		return fmt.Errorf("failed to get cveId from JSON data")
	}

	assignerOrgID, ok := cveMetadata["assignerOrgId"].(string)
	if !ok {
		return fmt.Errorf("failed to get assignerOrgId from JSON data")
	}

	state, ok := cveMetadata["state"].(string)
	if !ok {
		return fmt.Errorf("failed to get state from JSON data")
	}

	// Extract dateReserved field
	dateReserved, ok := cveMetadata["dateReserved"].(string)
	if !ok {
		dateReserved = "1970-01-01T00:00:00Z"
	}

	// Extract other fields as needed

	// Create CVEData struct with extracted fields
	cve := CVEData{
		AssignerOrgID: assignerOrgID,
		CVEID:         cveID,
		DateReserved:  dateReserved,
		State:         state,
		// Add other fields here
	}

	// Insert CVE into the database
	if err := upsertCVE(ctx, conn, cve); err != nil {
		return fmt.Errorf("failed to upsert CVE: %v", err)
	}
	return nil
}

// Upsert CVE into the database
func upsertCVE(ctx context.Context, conn *pgxpool.Pool, cve CVEData) error {
	// Marshal CVEData to JSON with specific key order
	jsonData, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal JSON data: %v", err)
	}

	query := `
        INSERT INTO cve.cves (cve_id, cve_data)
        VALUES ($1, $2)
        ON CONFLICT (cve_id) DO UPDATE
        SET cve_data = EXCLUDED.cve_data,
            version = CASE
                WHEN cve.cves.cve_data IS DISTINCT FROM EXCLUDED.cve_data THEN cve.cves.version + 1.0
                ELSE cve.cves.version
            END;
    `
	_, err = conn.Exec(ctx, query, cve.CVEID, jsonData)
	if err != nil {
		// Handle specific error for duplicate key violation
		if pgErr, ok := err.(*pgconn.PgError); ok && pgErr.Code == "23505" {
			// Handle duplicate record error
			fmt.Printf("CVE %s already exists in the database.\n", cve.CVEID)
			return nil
		}
		return fmt.Errorf("failed to upsert CVE %s: %v", cve.CVEID, err)
	}
	fmt.Printf("CVE %s upserted successfully.\n", cve.CVEID)
	return nil
}
