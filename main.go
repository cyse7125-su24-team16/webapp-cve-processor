package main

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl/plain"
)

const (
	cveDataDirectory = "cve_data"
	processedCVEFile = "processed_cve_ids.txt"
	version          = 1.0
)

// Global variables for Kafka configuration
var (
	kafkaBroker1  string
	kafkaBroker2  string
	kafkaBroker3  string
	kafkaTopic    string
	kafkaUsername string
	kafkaPassword string
	zipURL        string
)

// CVEData represents the structure of CVE data with specific field order
type CVEData struct {
	AssignerOrgID     string  `json:"assignerOrgId"`
	AssignerShortName string  `json:"assignerShortName"`
	CVEID             string  `json:"cveId"`
	DatePublished     string  `json:"datePublished"`
	DateReserved      string  `json:"dateReserved"`
	DateUpdated       string  `json:"dateUpdated"`
	State             string  `json:"state"`
	Version           float64 `json:"version"`
}

func main() {
	// Initialize Kafka configuration
	kafkaBroker1 = os.Getenv("KAFKA_BROKER1")
	kafkaBroker2 = os.Getenv("KAFKA_BROKER2")
	kafkaBroker3 = os.Getenv("KAFKA_BROKER3")
	kafkaTopic = os.Getenv("KAFKA_TOPIC")
	kafkaUsername = os.Getenv("KAFKA_USERNAME")
	kafkaPassword = os.Getenv("KAFKA_PASSWORD")
	zipURL = os.Getenv("ZIP_URL")

	if kafkaBroker1 == "" || kafkaBroker2 == "" || kafkaBroker3 == "" || kafkaTopic == "" || kafkaUsername == "" || kafkaPassword == "" {
		log.Fatal("Environment variables not set")
	}

	dialer := &kafka.Dialer{
		SASLMechanism: plain.Mechanism{
			Username: kafkaUsername,
			Password: kafkaPassword,
		},
	}

	ctx := context.Background()

	if zipURL == "" {
		fmt.Println("Environment variable ZIP_URL is not set")
		return
	}

	fmt.Println("Downloading and extracting CVE data...")
	// Download and extract CVE data from ZIP file URL
	if err := downloadAndExtractCVEData(zipURL, cveDataDirectory); err != nil {
		log.Fatalf("Failed to download and extract CVE data: %v\n", err)
	}
	fmt.Println("Completed downloading and extracting CVE data.")

	fmt.Println("Processing CVE data files...")
	// Process all CVE data files in the specified directory
	if err := processAllCVEDataFiles(ctx, cveDataDirectory, dialer); err != nil {
		log.Fatalf("Failed to process CVE data files: %v\n", err)
	}
	fmt.Println("Completed processing CVE data files.")

	// Send HTTP POST request to the endpoint
	resp, err := http.Post("http://127.0.0.1:15020/quitquitquit", "text/plain", nil)
	if err != nil {
		log.Fatalf("Failed to send HTTP POST request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to send HTTP POST request: status code %d", resp.StatusCode)
	}

	fmt.Println("HTTP POST request sent successfully.")
}

// Download and extract CVE data from a ZIP file URL
func downloadAndExtractCVEData(url, destDir string) error {
	fmt.Printf("Downloading ZIP file from %s...\n", url)
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download ZIP file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download ZIP file: status code %d", resp.StatusCode)
	}

	zipData, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read ZIP file data: %v", err)
	}

	zipReader, err := zip.NewReader(bytes.NewReader(zipData), int64(len(zipData)))
	if err != nil {
		return fmt.Errorf("failed to create ZIP reader: %v", err)
	}

	for _, file := range zipReader.File {
		filePath := filepath.Join(destDir, file.Name)

		if file.FileInfo().IsDir() {
			if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
				return fmt.Errorf("failed to create directory: %v", err)
			}
			continue
		}

		if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
			return fmt.Errorf("failed to create directory: %v", err)
		}

		outFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			return fmt.Errorf("failed to open file for writing: %v", err)
		}

		rc, err := file.Open()
		if err != nil {
			return fmt.Errorf("failed to open file in ZIP archive: %v", err)
		}

		_, err = io.Copy(outFile, rc)
		if err != nil {
			return fmt.Errorf("failed to copy file data: %v", err)
		}

		outFile.Close()
		rc.Close()
	}

	return nil
}

// Process all CVE data files in the specified directory
func processAllCVEDataFiles(ctx context.Context, dir string, dialer *kafka.Dialer) error {
	// Create Kafka writer
	writer := kafka.NewWriter(kafka.WriterConfig{
		Brokers: []string{kafkaBroker1, kafkaBroker2, kafkaBroker3},
		Topic:   kafkaTopic,
		Dialer:  dialer,
		// Use batching configuration
		BatchSize:    100,
		BatchBytes:   1048576, // 1 MB
		BatchTimeout: 10 * time.Millisecond,
	})
	defer writer.Close()

	var wg sync.WaitGroup
	filesChan := make(chan string, 10)

	// Launch a fixed number of goroutines for concurrent processing
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for filename := range filesChan {
				if err := processCVEDataFromFile(ctx, writer, filename); err != nil {
					log.Printf("Failed to process CVE data from file %s: %v", filename, err)

				}
			}
		}()
	}

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip processing specific files
		if strings.HasSuffix(path, "delta.json") || strings.HasSuffix(path, "deltaLog.json") {
			fmt.Printf("Skipping file %s...\n", path)
			return nil
		}

		if !info.IsDir() && strings.HasSuffix(path, ".json") {
			filesChan <- path
		}
		return nil
	})

	close(filesChan)
	wg.Wait()

	return err
}

// Process CVE data from a JSON file
func processCVEDataFromFile(ctx context.Context, writer *kafka.Writer, filename string) error {
	// Read JSON data from file
	jsonData, err := ioutil.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read JSON file %s: %v", filename, err)
	}

	// Parse JSON data
	var data map[string]interface{}
	if err := json.Unmarshal(jsonData, &data); err != nil {
		return fmt.Errorf("failed to parse JSON data: %v", err)
	}

	// Extract CVE metadata
	cveMetadata, ok := data["cveMetadata"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("failed to get cveMetadata from JSON data")
	}

	// Extract fields from cveMetadata
	cveID, ok := cveMetadata["cveId"].(string)
	if !ok {
		return fmt.Errorf("failed to get cveId from JSON data")
	}

	assignerOrgID, ok := cveMetadata["assignerOrgId"].(string)
	if !ok {
		return fmt.Errorf("failed to get assignerOrgId from JSON data")
	}

	state, ok := cveMetadata["state"].(string)
	if !ok {
		return fmt.Errorf("failed to get state from JSON data")
	}

	// Extract dateReserved field
	dateReserved, ok := cveMetadata["dateReserved"].(string)
	if !ok {
		dateReserved = "1970-01-01T00:00:00Z"
	}

	// Create CVEData struct with extracted fields
	cve := CVEData{
		AssignerOrgID: assignerOrgID,
		CVEID:         cveID,
		DateReserved:  dateReserved,
		State:         state,
		Version:       version,
	}

	// Check if CVE ID has been processed before
	if isCVEProcessed(cve.CVEID) {
		fmt.Printf("CVE %s has already been processed.\n", cve.CVEID)
		return nil
	}

	// Convert CVEData to JSON
	cveJSON, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal CVE data: %v", err)
	}

	// Publish CVE data to Kafka topic
	msg := kafka.Message{
		Key:   []byte(cve.CVEID),
		Value: cveJSON,
	}

	if err := writer.WriteMessages(ctx, msg); err != nil {
		return fmt.Errorf("failed to write message to Kafka: %v", err)
	}

	// Record processed CVE ID
	if err := recordProcessedCVE(cve.CVEID); err != nil {
		fmt.Printf("Failed to record processed CVE ID %s: %v\n", cve.CVEID, err)
	}

	fmt.Printf("CVE %s published to Kafka successfully.\n", cve.CVEID)
	return nil
}

// Check if CVE ID has been processed before
func recordProcessedCVE(cveID string) error {
	file, err := os.OpenFile(processedCVEFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open processed CVE file: %v", err)
	}
	defer file.Close()

	_, err = fmt.Fprintf(file, "%s\n", cveID)
	if err != nil {
		return fmt.Errorf("failed to write CVE ID to processed CVE file: %v", err)
	}
	return nil
}

// Check if CVE ID has been processed before
func isCVEProcessed(cveID string) bool {
	processedCVEs, err := ioutil.ReadFile(processedCVEFile)
	if err != nil {
		return false // Assume CVE ID is not processed if file doesn't exist
	}
	processedList := strings.Split(string(processedCVEs), "\n")
	for _, id := range processedList {
		if id == cveID {
			return true
		}
	}
	return false
}
