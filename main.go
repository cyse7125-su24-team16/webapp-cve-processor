package main

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4/pgxpool"
)

const (
	cveDataDirectory = "cve_data"
	processedCVEFile = "processed_cve_ids.txt"
	zipURL           = "$ZIP_URL"
	dbURL            = "$DB_URL"
)

// CVEData represents the structure of CVE data with specific field order
type CVEData struct {
	AssignerOrgID     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CVEID             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

func main() {

	dbURL := os.Getenv("DB_URL")
	zipURL := os.Getenv("ZIP_URL")

	if dbURL == "" || zipURL == "" {
		fmt.Println("Environment variables DB_URL or ZIP_URL are not set")
		return
	}

	ctx := context.Background()

	fmt.Println("Connecting to PostgreSQL...")
	// Connect to PostgreSQL
	conn, err := pgxpool.Connect(ctx, dbURL)
	if err != nil {
		log.Fatalf("Unable to connect to database: %v\n", err)
	}
	defer conn.Close()

	fmt.Println("Connected to PostgreSQL.")

	fmt.Println("Ensuring the CVEs table exists...")
	// Ensure the CVEs table exists
	if err := ensureTableExists(ctx, conn); err != nil {
		log.Fatalf("Failed to ensure table exists: %v\n", err)
	}
	fmt.Println("Ensured the CVEs table exists.")

	fmt.Println("Creating index on cve_data column...")
	// Create index on cve_data column
	if err := createIndexOnCVEData(ctx, conn); err != nil {
		log.Fatalf("Failed to create index on cve_data column: %v\n", err)
	}
	fmt.Println("Index on cve_data column created successfully.")

	fmt.Println("Downloading and extracting CVE data...")
	// Download and extract CVE data from ZIP file URL
	if err := downloadAndExtractCVEData(zipURL, cveDataDirectory); err != nil {
		log.Fatalf("Failed to download and extract CVE data: %v\n", err)
	}
	fmt.Println("Completed downloading and extracting CVE data.")

	fmt.Println("Processing CVE data files...")
	// Process all CVE data files in the specified directory
	if err := processAllCVEDataFiles(ctx, conn, cveDataDirectory); err != nil {
		log.Fatalf("Failed to process CVE data files: %v\n", err)
	}
	fmt.Println("Completed processing CVE data files.")
}

// Ensure the table exists
func ensureTableExists(ctx context.Context, conn *pgxpool.Pool) error {
	const createTableQuery = `
    CREATE TABLE IF NOT EXISTS cve.cves (
        cve_id TEXT PRIMARY KEY,
        cve_data JSONB,
        version NUMERIC DEFAULT 1.0
    );
    `
	_, err := conn.Exec(ctx, createTableQuery)
	return err
}

// Create index on cve_data column
func createIndexOnCVEData(ctx context.Context, conn *pgxpool.Pool) error {
	const createIndexQuery = `
    CREATE INDEX IF NOT EXISTS idx_cve_data ON cve.cves USING GIN (cve_data);
    `
	_, err := conn.Exec(ctx, createIndexQuery)
	return err
}

// Download and extract CVE data from a ZIP file URL
func downloadAndExtractCVEData(url, destDir string) error {
	fmt.Printf("Downloading ZIP file from %s...\n", url)
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download ZIP file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download ZIP file: status code %d", resp.StatusCode)
	}

	zipData, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read ZIP file data: %v", err)
	}

	zipReader, err := zip.NewReader(bytes.NewReader(zipData), int64(len(zipData)))
	if err != nil {
		return fmt.Errorf("failed to create ZIP reader: %v", err)
	}

	for _, file := range zipReader.File {
		filePath := filepath.Join(destDir, file.Name)

		if file.FileInfo().IsDir() {
			if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
				return fmt.Errorf("failed to create directory: %v", err)
			}
			continue
		}

		if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
			return fmt.Errorf("failed to create directory: %v", err)
		}

		outFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			return fmt.Errorf("failed to open file for writing: %v", err)
		}

		rc, err := file.Open()
		if err != nil {
			return fmt.Errorf("failed to open file in ZIP archive: %v", err)
		}

		_, err = io.Copy(outFile, rc)
		if err != nil {
			return fmt.Errorf("failed to copy file data: %v", err)
		}

		outFile.Close()
		rc.Close()
	}

	return nil
}

// Process all CVE data files in the specified directory
func processAllCVEDataFiles(ctx context.Context, conn *pgxpool.Pool, dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip processing specific files
		if strings.HasSuffix(path, "delta.json") || strings.HasSuffix(path, "deltaLog.json") {
			fmt.Printf("Skipping file %s...\n", path)
			return nil
		}

		if !info.IsDir() && strings.HasSuffix(path, ".json") {
			if err := processCVEDataFromFile(ctx, conn, path); err != nil {
				log.Printf("Failed to process CVE data from file %s: %v", path, err)
				// Continue to process other files even if one fails
			}
		}
		return nil
	})
}

// Process CVE data from a JSON file
func processCVEDataFromFile(ctx context.Context, conn *pgxpool.Pool, filename string) error {
	// Read JSON data from file
	jsonData, err := ioutil.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("failed to read JSON file %s: %v", filename, err)
	}

	// Parse JSON data
	var data map[string]interface{}
	if err := json.Unmarshal(jsonData, &data); err != nil {
		return fmt.Errorf("failed to parse JSON data: %v", err)
	}

	// Extract CVE metadata
	cveMetadata, ok := data["cveMetadata"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("failed to get cveMetadata from JSON data")
	}

	// Extract fields from cveMetadata
	cveID, ok := cveMetadata["cveId"].(string)
	if !ok {
		return fmt.Errorf("failed to get cveId from JSON data")
	}

	assignerOrgID, ok := cveMetadata["assignerOrgId"].(string)
	if !ok {
		return fmt.Errorf("failed to get assignerOrgId from JSON data")
	}

	state, ok := cveMetadata["state"].(string)
	if !ok {
		return fmt.Errorf("failed to get state from JSON data")
	}

	// Extract dateReserved field
	dateReserved, ok := cveMetadata["dateReserved"].(string)
	if !ok {
		dateReserved = "1970-01-01T00:00:00Z"
	}

	// Create CVEData struct with extracted fields
	cve := CVEData{
		AssignerOrgID: assignerOrgID,
		CVEID:         cveID,
		DateReserved:  dateReserved,
		State:         state,
	}

	// Check if CVE ID has been processed before
	if isCVEProcessed(cve.CVEID) {
		fmt.Printf("CVE %s has already been processed.\n", cve.CVEID)
		return nil
	}

	// Insert CVE into the database
	if err := upsertCVE(ctx, conn, cve); err != nil {
		return fmt.Errorf("failed to upsert CVE: %v", err)
	}

	// Record processed CVE ID
	if err := recordProcessedCVE(cve.CVEID); err != nil {
		fmt.Printf("Failed to record processed CVE ID %s: %v\n", cve.CVEID, err)
	}

	fmt.Printf("CVE %s upserted successfully.\n", cve.CVEID)
	return nil
}

// Upsert CVE into the database
func upsertCVE(ctx context.Context, conn *pgxpool.Pool, cve CVEData) error {
	// Marshal CVEData to JSON with specific key order
	jsonData, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal JSON data: %v", err)
	}

	query := `
        INSERT INTO cve.cves (cve_id, cve_data)
        VALUES ($1, $2)
        ON CONFLICT (cve_id) DO UPDATE
        SET cve_data = EXCLUDED.cve_data,
            version = CASE
                WHEN cve.cves.cve_data IS DISTINCT FROM EXCLUDED.cve_data THEN cve.cves.version + 1.0
                ELSE cve.cves.version
            END;
    `
	_, err = conn.Exec(ctx, query, cve.CVEID, jsonData)
	if err != nil {
		// Handle specific error for duplicate key violation
		if pgErr, ok := err.(*pgconn.PgError); ok && pgErr.Code == "23505" {
			// Handle duplicate record error
			fmt.Printf("CVE %s already exists in the database.\n", cve.CVEID)
			return nil
		}
		return fmt.Errorf("failed to upsert CVE %s: %v", cve.CVEID, err)
	}
	return nil
}

// Record processed CVE ID into a text file
func recordProcessedCVE(cveID string) error {
	file, err := os.OpenFile(processedCVEFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open processed CVE file: %v", err)
	}
	defer file.Close()

	_, err = fmt.Fprintf(file, "%s\n", cveID)
	if err != nil {
		return fmt.Errorf("failed to write CVE ID to processed CVE file: %v", err)
	}
	return nil
}

// Check if CVE ID has been processed before
func isCVEProcessed(cveID string) bool {
	processedCVEs, err := ioutil.ReadFile(processedCVEFile)
	if err != nil {
		return false // Assume CVE ID is not processed if file doesn't exist
	}
	processedList := strings.Split(string(processedCVEs), "\n")
	for _, id := range processedList {
		if id == cveID {
			return true
		}
	}
	return false
}
