def releaseTag
def newVersion

pipeline {
    agent any

    environment {
        DOCKER_CREDENTIALS_ID = 'docker_credentials'
        DOCKER_TAG = 'latest'
        GITHUB_CREDENTIALS_ID = 'github_token'
        GITHUB_REPO = 'cyse7125-su24-team16/webapp-cve-processor'
        DOCKER_HUB_REPO = '118a3025/img1'
    }

    options {
        skipDefaultCheckout(true)
    }

    triggers {
        githubPush()
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    // Checkout the code
                    git credentialsId: GITHUB_CREDENTIALS_ID, url: "https://github.com/${env.GITHUB_REPO}.git", branch: 'main'
                }
            }
        }

        stage('Fetch and Checkout PR Branch') {
            when {
                expression {
                    return env.CHANGE_ID != null
                }
            }
            steps {
                script {
                    // Fetch the latest changes from the origin using credentials
                    withCredentials([usernamePassword(credentialsId: GITHUB_CREDENTIALS_ID, usernameVariable: 'GITHUB_USER', passwordVariable: 'GITHUB_TOKEN')]) {
                        sh 'git config --global credential.helper store'
                        sh 'echo "https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com" > ~/.git-credentials'
                        // Fetch all branches including PR branches
                        sh 'git fetch origin +refs/pull/*/head:refs/remotes/origin/pr/*'
                        // Dynamically fetch the current PR branch name using environment variables
                        def prBranch = env.CHANGE_BRANCH
                        echo "PR Branch: ${prBranch}"
                        // Checkout the PR branch
                        sh "git checkout -B ${prBranch} origin/pr/${env.CHANGE_ID}"
                    }
                }
            }
        }

        stage('Check Commit Messages') {
            when {
                expression {
                    return env.CHANGE_ID != null
                }
            }
            steps {
                script {
                    // Fetch the latest commit message in the PR branch
                    def latestCommitMessage = sh(script: "git log -1 --pretty=format:%s", returnStdout: true).trim()
                    echo "Latest commit message: ${latestCommitMessage}"

                    // Regex for Conventional Commits
                    def pattern = ~/^\s*(feat|fix|docs|style|refactor|perf|test|chore)(\(.+\))?: .+\s*$/

                    // Check the latest commit message
                    if (!pattern.matcher(latestCommitMessage).matches()) {
                        error "Commit message does not follow Conventional Commits: ${latestCommitMessage}"
                    }
                }
            }
        }

        stage('Semantic-Release') {
            when {
                allOf {
                    branch 'main'
                    not { changeRequest() }
                }
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github_token', usernameVariable: 'GH_USERNAME', passwordVariable: 'GH_TOKEN')]) {
                        env.GIT_LOCAL_BRANCH = 'main'
                        def releaseOutput = sh(script: 'npx semantic-release --dry-run --json', returnStdout: true).trim()
                        def versionLine = releaseOutput.find(/Published release (\d+\.\d+\.\d+) on default channel/)

                        if (versionLine) {
                            // Extract the new version
                            newVersion = (versionLine =~ /(\d+\.\d+\.\d+)/)[0][0]
                            echo "New version: v${newVersion}"
                            
                            // Package code
                            sh "tar -czvf source-code-v${newVersion}.tar.gz --exclude='.git' --exclude='*.tar.gz' --exclude='*.zip' ."

                            // Create GitHub release and upload the artifacts
                            sh """
                            gh release create v${newVersion} source-code-v${newVersion}.tar.gz \\
                            --repo ${env.GITHUB_REPO} \\
                            --title "Release v${newVersion}" \\
                            --notes "Automatically generated release by Jenkins pipeline."
                            rm source-code-v${newVersion}.tar.gz
                            """
                        } else {
                            error "Failed to capture the new version from semantic-release."
                        }
                    }
                }
            }
        }

        stage('Setup Buildx') {
            steps {
                script {
                    // Setup Buildx for multi-platform builds
                    sh '''
                    docker run --privileged --rm tonistiigi/binfmt --install all
                    docker buildx create --use --name mybuilder --driver docker-container
                    docker buildx inspect mybuilder --bootstrap
                    '''
                }
            }
        }

        stage('Clean Docker') {
            steps {
                script {
                    // Clean up Docker space
                    sh 'docker system prune -af'
                    sh 'docker volume prune -f'
                }
            }
        }

        stage('Build Docker Images') {
            when {
                allOf {
                    branch 'main'
                    not { changeRequest() }
                }
            }
            steps {
                script {
                    docker.withRegistry('https://index.docker.io/v1/', DOCKER_CREDENTIALS_ID) {
                        def tagExists = sh(script: 'git tag -l', returnStatus: true) == 0
                        if (tagExists) {
                            releaseTag = sh(returnStdout: true, script: 'git describe --tags --abbrev=0').trim()
                            echo "Release tag is ${releaseTag}"
                        } else {
                            releaseTag = "latest"
                            echo "No tags found, using 'latest' as the release tag."
                        }

                       sh '''
                        docker buildx build --builder mybuilder -f Dockerfile.flyway -t pg-migration:${DOCKER_TAG} --platform "linux/arm64,linux/amd64" . --push
                        docker tag pg-migration:${DOCKER_TAG} ${DOCKER_HUB_REPO}:pg-migration
                        docker push ${DOCKER_HUB_REPO}:pg-migration

                        docker system prune -af
                        docker volume prune -f
                        
                        docker buildx build --builder mybuilder -f Dockerfile.app -t webapp:${DOCKER_TAG} --platform "linux/arm64,linux/amd64" . --push
                        docker tag webapp:${DOCKER_TAG} ${DOCKER_HUB_REPO}:webapp
                        docker push ${DOCKER_HUB_REPO}:webapp

                        docker system prune -af
                        docker volume prune -f
                        '''
                     
                    }
                }
            }
        }

        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }
    }

    post {
        failure {
            script {
                echo "Pipeline failed."
            }
        }
        success {
            script {
                echo "Pipeline succeeded."
            }
        }
    }
}
